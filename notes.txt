Bookmark currently on foundry fund me 20. Optimise the withdraw function gas costs

// Concepts we didn't cover yet (will cover in later sections)
// 1. Enum
// 2. Events
// 3. Try / Catch
// 4. Function Selector
// 5. abi.encode / decode
// 6. Hash with keccak256
// 7. Yul / Assembly

WEBSITE BOOKMARKS
DEVELOPMENT
evm.codes(shows you storage gas costs)
cartesi.io/simple(put Linux onchain Radically simple Next generation powerful.)
chainlist.org (connect to EVM powered networks)
alchemy.com(Blockchain development platform)
speedrunethereum.com(Learn how to build on Ethereum)
solidity-by-example.com(solidity examples to help with development)
ethstats.dev(shows whats going on with the EVM)
eth-converter.com(Simple Unit Converter)
docs.chain.link(chainlink developer docs)
faucets.chain.link(developer faucets)
FOUNDRY CHEAT CODES (https://book.getfoundry.sh/forge/cheatcodes)
L2
l2beat.com(information about Layer 2s)
explorer.zksync.io(zksync era block explorer)
docs.zksync.io/zk-stack/concepts/transaction-lifecycle(In depth guide on transaction lifecycle within the zk stack)
portal.zksync.io/bridge/(bridge sepolia testet funds to zksync)
docs.zksync.io/ecosystem/network-faucets(more faucets)
AI
learn.deeplearning.ai(courses to learn about ai)
phind.com(great development ai tool)
gemini.google.com(another good ai for development)

STYLE GUIDES/TIPS
https://docs.soliditylang.org/en/latest/style-guide.html(solidity style guide tips to help with organization and look like a professional)

FOUNDRY NOTES
INSTALLATION
Install vscodium, on windows terminal wsl --install to install linux, Extensions for vscodium are solidity and hardhat support, better toml, and markdown all in one for the README.md to open preview ctrl + shift + p then open markdown open preview

ITS IMPORTANT TO ALWAYS MAKE A README.md FILE (uses markdown syntax)
to keep all the information about our project so when we share with others they know how our project works and any helpful information. Information about how your project works, instructions on how to work with it, and contact information *type ctrl + shift + p and search for markdown preview this will show you what it will look like on a github repository

After installing wsl and sudo apt install foundry and foundryup *(curl -L https://foundry.paradigm.xyz | bash
) and git *type git config --global user.name "matcherbudz" && git config --global user.email "email@email.com"


START HERE
To create a new project create a new directory and initialize *type mkdir name then cd into the directory then *type forge init or forge init --force

IF YOU WANT TO OPEN A NEW WINDOW IN VSCODE TYPE code foundy-fund-me-f25 (name of directory)

Now were going to deploy the smart contract using a script from now on this is the main way to deploy our smart contracts to test them and test the deployment.

To have a contract deploy our SimpleStorage contract we want to import Scripts from the forge-std library
in the script folder we make a file called DeploySimpleStorage.s.sol (the .s.sol is just a foundry convention most of the time scripts have a .s.sol)
to import from the forge-std library *type import{Script} from "forge-std/Script.sol"; then in our contract name inherit the Script library *like contract SimpleStorage is Script {}
to deploy *type forge script script/DeploySimpleStorage.s.sol and it will create a temp vm to deploy contract 

PRIVATE KEY ENCRYPTION DO THIS IN A SEPERATE TERMINAL
To save your private keys in a encrypted way directory on forge open a seperate terminal and *type cast wallet import defaultKey --interactive to use in deployment *type --account defaultKey --sender 0x00 (public address sender associated with private key)

ADDING A LOCAL NETWORK ON METAMASK
for anvil deploying onchain we need to add it to metamask. network name localhost(or whatever we want to name it) rpc url http://127.0.0.1:8545, chain id 31337, currency symbol ETH

TO DEPLOY ONCHAIN
if using .env for rpc url *type source.env
 now if you want to deploy onchain run anvil and *type forge script script/DeploySimpleStorage.s.sol --rpc-url http://url --account defaultKey --sender 0x00 (public address sender associated with private key) --broadcast -vvvv

INTERACTING WITH THE SMART CONTRACT USING THE CLI USING CAST
in the example SimpleStorage if we want to call the store function and send the transaction *type cast send 0x00(contract address) "store(uint256)" 123(arguments or value we want to pass to the store function) --rpc-url http://url --account defaultKey

Now if we want to call the retrieve function or any call function *type cast call 0x00(contract address) "retrieve()" this will show you the hex value 0x00... to convert this to the number stored *type cast --to-base 0x00...(hex) dec

DEPLOYING TO SEPOLIA
Until I can run my own ethereum node, We can use alchemy.com which is a free node as a service to send transactions to. Create a New app and make sure youre on the right network. copy the https rpc url. Use a private key from one of the development metamask (NEVER REVEAL PRIVATE KEYS WHEN DEALING WITH REAL MONEY) *type cast wallet import metaMaskKey --interactive. (dont forget source .env when using rpc urls) Now to deploy *type forge script script/DeploySimpleStorage.s.sol --rpc-url $SEPOLIA_RPC_URL (or paste the url) --account metaMaskKey --sender $SEPOLIA_PUBLIC_KEY 0x00 (public key associated with private key) --broadcast (dont forget to check the transaction on the sepolia block explorer)

DEPLOYING TO ZKSYNC
First insall zksync foundry *type git clone https://github.com/matter-labs/foundry-zksync.git if that doesnt work remove the .git so were left with whatever the url is at the moment this will create a new directory foundry-zksync then go to the foundry zksync install page https://foundry-book.zksync.io/getting-started/installation and copy and paste the install then then *type foundryup-zksync to use then foundryup to go back to vanilla *next cd into the directory and run the installer *type 
./install-foundry-zksync (for help *type forge build --help) Now we can comple *type forge build --zksync and it will create a zkout folder which contains all the compilation details for zksync.

DEPLOYING TO A LOCALLY RUNNING ZKSYNC NODE (OUTDATED BUT STILL GOOD TO KNOW)
We want to make sure our smart contracts work properly on zksync to make sure we can use a locally running chain to do this first make sure you're on foundryup-zksync, then install and run docker, next were going to install nodejs and npm go to nodejs.org/en/download/package-manager chose the version, operating system, and package manager (nvm) to make sure theyre all installed type npm --version npx --version and node --version. Next were going to use the zksync-cli we can refer to the documentation to learn more docs.zksync.io/build/tooling/zksync-cli/getting-started.html (Its a tool that makes developing with zksync a little bit easier) Were going to use the zksync-cli to run a local zksync node a minimized zksync node. 
SPINNING UP THE DOCKER ZKSYNC NODE
To do this *type npx zksync-cli dev config (this is going to prompt us with In memory node or Dockerized node chose the In memory node - Quick startup, no persisted state, only L2 node. the name might be different the next time we do this) Next we dont need a portal or the block explorer so just press enter. It should say Configuration saved successfully (check docker ps) then *type npx zksync-cli dev start (now if we run docker ps it will have more information) the ps means that a process in running in the background with docker. Next it will give us the node information the Chain ID, RPC URL (http://127.0.0.1:8011, chain id 260), and at the link (https://docs.zksync.io/build/test-and-debug/in-memory-node#pre-configured-rich-wallets) will give us account keys. to save ind encrypted way *type cast wallet import zkSyncKey --interactive to use in deployment *type --account zkSyncKey --sender 0x00 (public address sender associated with private key) 
DEPLOYING
check forge --version should be 0.0.2 now *type forge create SimpleStorage --rpc-url $ZKSYNC_RPC_URL --account zkSyncKey --sender $ZKSYNC_PUBLIC_KEY --legacy --zksync (the --legacy may change one day but for now add the --legacy) this will fail because right now its not smart enough to know where the SimpleStorage contract is so we will change it to 
*type forge create src/SimpleStorage.sol:SimpleStorage (here were saying in the src folder grab the SimpleStorage.sol file and in the file grab the SimpleStorage Contract) --rpc-url $ZKSYNC_RPC_URL --account zkSyncKey --sender $ZKSYNC_PUBLIC_KEY --legacy --zksync (dont forget to go back to vanilla before continuing *type foundryup) 

DEPLOYING TO A LOCALLY RUNNING ZKSYNC NODE (NEWEST INFORMATION)

FOUNDRY FUND ME NOTES

INSTALLING DEPENDENCIES
If we try to compile it will give us errors unable to resolve imports because foundry doens't reach out to the NPM package repository for the aggregatorv3interface. The solution is we need to be explicit and tell foundry where to pull our dependencies from. To install the dependency we go to the github repository and copy the name of the org and the repository then we *type forge install smartcontractkit/chainlink-brownie-contracts@1.3.0(the @ sign makes sure were using the version we want) --no-commit(most of the time were going to add the --no-commit) OR the whole webiste url with the @version so we *type forge install https://github.com/smartcontractkit/chainlink-brownie-contracts@1.3.0 --no-commit 

REMAPPING
we need to create a remapping in the foundry.toml file to tell foundry @chainlink/contracts/ should point to our new lib folder we just insalled. to do this open the foundry.toml file and *type 
remappings = ["@chainlink/contracts/=lib/chainlink-brownie-contracts/contracts/"] (if you want to see the entire list of possibilities that can go in here go to the link that is inside of foundry.toml)

HANDLING ERRORS 
When naming errors its a good practice to name the errors after the contract for example *error FundMe__NotOwner(); (This way we can easily tell what contract the error is coming from)

TESTING OUR CONTRACTS

FOUR DIFFERENT TYPES OF TESTS
1) Unit - Testing a specific part of our code
2) Integration - Testing how our code works with other parts of Our code
3) Forked - Testing our code on a simulated real enviroment
4) Staging - Testing our code in a real enviroment that is not production

Writing tests for our smart contracts is critical for our development journey, if we try to deploy our smart contracts without tests or go to a smart contract auditor without a test they will turn you away. Writing good tests seperates the mediocre devs from the really good devs. In the test folder name the file our example is *FundMeTest.t.sol(the .t is a convention in solidity saying this is a test file) similar to our SimpleStorage contract we will *import{Test} from "forge-std/Test.sol"; and inherit by typing contract FundMeTest is Test {} also import our contract we want to test *import {FundMe} from "../src/FundMe.sol"; 

then we add a setup function called function setUp() external {} (on all of our tests the first thing that happens it this setUp function in here is where we are going to deploy our contract) then we add a scope to the contract at the top by *typing FundMe fundMe; and in the setUp function we do fundMe = new FundMe(); saying our fundMe variable is a new FundMe(); contract, now we can pick a function or a variable in the FundMe contract to test to do this we add a function and name it explicitly in this example were testing the MINIMUM_USD variable since MINIMUM_USD is a public variable we can test it to make sure it is 5e18. to do this we write the function * function testMinimumDollarsIsFive() public view {assertEq(fundMe.)} inside the function we use assertEq which is a function provided by foundry testing framework that is used to assert that two values are equal and add the fundMe with the function or variable were testing like assertEq(fundMe.MINIMUM_USD(), 5E18);

TESTING A SPECIFIC FUNCTION
when testing and we want to test a specific function or variable so were not blasted with too much information it used to be function test -m nameOfFunction but -m is now no longer supported so now we *type forge test --mt nameOfFunction -vvvvv(the v stands for verbose depending on how much information we want is how many vs we put)
WHEN TESTING OUR testPriceFeedVersionIsAccurate it reverts because were calling a contract address that doesnt exist when we run the test and dont specify a chain foundry will automatically spin up a temporary anvil chain for us. to fix this we can use a simulated real enviroment to test to do this we can use alchemy or another service and copy the rpc url and (if using .env dont forget to type source .env) *type forge test --mt testPriceFeedVersionIsAccurate -vvvv --fork-url $SEPOLIA_RPC_URL(--rpc-url http://) we need to be careful doing this though becuase using forked tests uses a lot of api call which can run up our bill.

COVERAGE
we can use something called *forge coverage --fork-url $SEPOLIA_RPC_URL(--rpc-url http://) we want to get the percantage as high as possible that makes sense.

STORAGE LAYOUT
To check first way you can use *type forge inspect FundMe(contract name) storageLayout (this will show you the exact layout of storage that your contract has)
The other way we can see storage is using cast storage. If we run anvil then *type forge script script/DeployFundMe.s.sol --rpc-url http://127.0.0.1:8545 --private-key 0x00 --broadcast then grab the contract address and paste it into * cast storage 0x00 X (X is the storage slot for example if you type 2 it will show you whats in the third slot)

CALCULATING GAS USAGE
if you want to get a snapshot of the gas usage *type forge snapshot and it will save a file .gas-snapshot 

Etherscan provides a super nice tool that we can use: <https://etherscan.io/gastracker>. Here, at the moment I'm writing this lesson, it says that the gas price is around `7 gwei`. If we multiply the two it gives us a total price of `593,768 gwei`. Ok, at least that's an amount we can work with. Now we will use the handy [Alchemy converter](https://www.alchemy.com/gwei-calculator) to find out that `593,768 gwei = 0.000593768 ETH` and `1 ETH = 2.975,59 USD` according to [Coinmarketcap](https://coinmarketcap.com/) meaning that our transaction would cost `1.77 USD` on Ethereum mainnet. Let's see if we can lower this.

When testing our contracts on anvil the default gas price is 0 to change this we need to force the transactions to have a gas price by using these cheatcodes. At the top of your `FundMeTest` contract define the following variable:

uint256 constant GAS_PRICE = 1; (the 1 stands for the amount of wei)

and refactor the `testWithdrawFromASingleFunder` function as follows:

function testWithdrawFromASingleFunder() public funded {
    // Arrange
    uint256 startingFundMeBalance = address(fundMe).balance;
    uint256 startingOwnerBalance = fundMe.getOwner().balance;

    **vm.txGasPrice(GAS_PRICE);
    **uint256 gasStart = gasleft();

    // Act
    vm.startPrank(fundMe.getOwner());
    fundMe.withdraw();
    vm.stopPrank();

    **uint256 gasEnd = gasleft();
    **uint256 gasUsed = (gasStart - gasEnd) * tx.gasprice;
    **console.log("Withdraw consumed: %d gas", gasUsed);

    // Assert
    uint256 endingFundMeBalance = address(fundMe).balance;
    uint256 endingOwnerBalance = fundMe.getOwner().balance;
    assertEq(endingFundMeBalance, 0);
    assertEq(
        startingFundMeBalance + startingOwnerBalance,
        endingOwnerBalance
    );

}

WRITING A README
Writing a README.md

A README is often the first item a visitor will see when visiting your repository. It serves as an introduction to your project, explaining what it does, why it is useful, and how users can get started with it. This initial impression can significantly impact whether someone decides to explore your project further.

There are multiple templates available on the internet, but generally, yours should include at least a Title, a Project Overview, a Getting Started Guide and maybe some Contribution Guidelines (if you are building an open-source project).

A README is your project's face to the world, and investing time in making it clear, comprehensive, and engaging can significantly impact your project's success and community engagement.

Using the Extension Markdown All In One and using *ctrl + shift + p and typing in preview will show you what the readme will look like on your github page

CREATING INTEGRATION TESTS
To seamlessly interact with our contract, we need to create a programmatic way to use it's functions.

Please create a new file called `Interactions.s.sol` in the `script` folder.

In this file, we will create two scripts, one for funding and one for withdrawing.

Each contract will contain one script, and for it to work each needs to inherit from the Script contract. Each contract will have a `run` function which shall be called by `forge script` when we run it.

In order to properly interact with our `fundMe` contract we would want to interact only with the most recent deployment we made. This task is easily achieved using the `foundry-devops` library. Please install it using the following command:

forge install Cyfrin/foundry-devops --no-commit

We've created a new function called `fundFundMe` which takes an address corresponding to the most recently deployed `FundMe` contract. Inside we start and stop a broadcast which sends a transaction calling the `fund` function from the `FundMe` contract. We've imported `console` to be able to log the amount that we funded as a confirmation. Inside the `run` function, we call `get_most_recent_deployment` from the DevOpsTools to get the address of the most recently deployed `FundMe` contract. We then use the newly acquired address as input for the `fundFundMe` function.

The same thing is done for `WithdrawFundMe`.

We could run this using the standard `forge script script/Interactions.s.sol:FundFundMe --rpc-url xyz --private-key etc ...` command, but writing that over and over again is not cool. We could test how this behaves using integration tests.

Integration tests are crucial for verifying how your smart contract interacts with other contracts, external APIs, or decentralized oracles that provide data feeds. These tests help ensure your contract can properly receive and process data, send transactions to other contracts, and function as intended within the wider ecosystem.

Before starting with the integration tests let's organize our tests into folders. Let's separate unit tests from integration tests by creating separate folders inside the `test` folder.

Create two new folders called `integration` and `unit` inside the `test` folder. Move `FundMeTest.t.sol` inside the `unit` folder. Make sure to update `FundMeTest.t.sol` to accommodate this change.

Run a quick `forge test` to ensure that everything builds and all tests pass.

Inside the `integration` folder create a new file called `FundMeTestIntegration.t.sol`

You will see that the first half, including the `setUp` is similar to what we did in `FundMe.t.sol`. The test `testUserCanFundAndOwnerWithdraw` has a similar structure to `testWithdrawFromASingleFunder` from `FundMe.t.sol`. We record the starting balances, we use `alice` to fund the contract then the `WithdrawFundMe` script to call `withdraw`. The next step is recording the ending balances and running the same assertions we did in `FundMe.t.sol`.

Run the integration test using the following command:

`forge test --mt testUserCanFundAndOwnerWithdraw -vv`

**Note 1:** Depending on when you go through this lesson there is a small chance that `foundry-devops` library has a problem that prevents you from building. The reason this happening is `vm.keyExists` used at `foundry-devops/src/DevOpsTools.sol:119` is deprecated. Please replace `vm.keyExists` with `vm.keyExistsJson` in the place indicated. Next, we need to make sure that the `Vm.sol` contract in your forge-std library contains the `vm.keyExistsJson`. If you can't find it in your `Vm.sol` then please run the following command in your terminal: `forge update --force`. If you still can't `forge build` the project the please come ask questions in the Updraft section of Cyfrin's discord.

**Note 2:**

Inside the video lesson, Patrick touched on the subject of `ffi`. We didn't present it at length in the body of this lesson because `foundry-devops` doesn't need it anymore. But in short:

Forge FFI, which stands for Foreign Function Interface, is a cheatcode within the Forge testing framework for Solidity. It allows you to execute arbitrary shell commands directly from your Solidity test code.

* FFI enables you to call external programs or scripts from within your Solidity tests.
* You provide the command or script name along with any arguments as an array of strings.
* The Forge testing framework then executes the command in the underlying system environment and captures the output.

Read more about it [here](https://book.getfoundry.sh/cheatcodes/ffi?highlight=ffi#ffi).

A word of caution: FFI bypasses the normal security checks and limitations of Solidity. By running external commands, you introduce potential security risks if not used carefully. Malicious code within the commands you execute could compromise your setup. Whenever you clone repos or download other projects please make sure they don't have `ffi = true` in their `foundry.toml` file. If they do, we advise you not to run anything before you thoroughly examine where `ffi` is used and what commands is it calling. Stay safe!

AUTOMATING YOUR SMART CONTRACTS ACTIONS - Makefile
having to write out scripts takes time there has to be an easier way to do this. The answer is Makefile!

A `Makefile` is a special file used in conjunction with the `make` command in Unix-based systems and some other environments. It provides instructions for automating the process of building software projects.

The main advantages of using a `Makefile` are:

* Automates tasks related to building and deploying your smart contracts.
* Integrates with Foundry commands like `forge build`, `forge test` and `forge script`.
* Can manage dependencies between different smart contract files.
* Streamlines the development workflow by reducing repetitive manual commands.
* Allows you to automatically grab the `.env` contents.

In the root folder of your project create a new file called `Makefile`.\

examples: (the :; with the semicolon means the code will be on the same line if not then just use :)
-include .env
build:; forge build

deploy-sepolia:
	forge script script/DeployFundMe.s.sol:DeployFundMe --rpc-url $SEPLOIA_RPC_URL --private-key $PRIVATE_KEY --broadcast --verify --etherscan-api-key $ETHERSCAN_API_KEY -vvvv

After creating the file run `make` in your terminal.
If you have `make` installed then you should receive the following message:
`make: *** No targets.  Stop` 
If not install make. Look at the makefile example in our fund me project example to see how it works. at the top we include the .env